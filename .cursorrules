# Cursor Rules - Autocar Location App

## üéØ CONTEXTE DU PROJET

- Application Next.js 15+ avec TypeScript en app router
- Syst√®me de r√©servation d'autocars avec gestion d'utilisateurs et partenaires
- Interface admin/client avec authentification
- Utilise Prisma + PostgreSQL pour la base de donn√©es
- shadcn/ui pour les composants UI avec Tailwind CSS

## üìÅ STRUCTURE DU PROJET

### Architecture des dossiers

```
app/
‚îú‚îÄ‚îÄ api/                    # Routes API
‚îú‚îÄ‚îÄ admin/                  # Pages admin
‚îú‚îÄ‚îÄ dashboard/              # Dashboard client
‚îú‚îÄ‚îÄ login/                  # Authentification
‚îú‚îÄ‚îÄ register/               # Inscription
‚îú‚îÄ‚îÄ contact/                # Contact
‚îú‚îÄ‚îÄ partners/               # Partenaires
‚îú‚îÄ‚îÄ profile/                # Profil utilisateur
‚îú‚îÄ‚îÄ quote/                  # Demande de devis
‚îú‚îÄ‚îÄ layout.tsx              # Layout principal
‚îú‚îÄ‚îÄ page.tsx                # Page d'accueil
‚îî‚îÄ‚îÄ globals.css             # Styles globaux

components/
‚îú‚îÄ‚îÄ ui/                     # Composants shadcn/ui
‚îú‚îÄ‚îÄ navbar.tsx              # Navigation
‚îú‚îÄ‚îÄ quote-form.tsx          # Formulaire de devis
‚îî‚îÄ‚îÄ autocomplete-component.tsx

lib/
‚îú‚îÄ‚îÄ utils.ts                # Utilitaires (cn, formatters, etc.)
‚îú‚îÄ‚îÄ auth-context.tsx        # Contexte d'authentification
‚îú‚îÄ‚îÄ quote-context.tsx       # Contexte des devis
‚îú‚îÄ‚îÄ partner-context.tsx     # Contexte des partenaires
‚îú‚îÄ‚îÄ message-context.tsx     # Contexte des messages
‚îú‚îÄ‚îÄ providers.tsx           # Providers React
‚îî‚îÄ‚îÄ data.ts                 # Donn√©es mock/statiques

prisma/
‚îî‚îÄ‚îÄ schema.prisma           # Sch√©ma de base de donn√©es
```

## üî® R√àGLES DE D√âVELOPPEMENT

### 1. TYPESCRIPT & REACT

- TOUJOURS utiliser TypeScript avec des types stricts
- Utiliser `type` au lieu d'`interface` pour les props
- Ne JAMAIS utiliser `React.FC`, d√©clarer directement les props
- Pr√©f√©rer `const` pour les composants
- Ne JAMAIS utiliser la variable `t` de `useTranslation` dans les d√©pendances d'`useEffect`

```typescript
// ‚úÖ BON
type Props = {
  title: string;
  isVisible?: boolean;
};

const MyComponent = ({ title, isVisible = false }: Props) => {
  return <div>{title}</div>;
};

// ‚ùå √âVITER
const MyComponent: React.FC<Props> = ({ title }) => {
  // ...
};
```

### 2. CR√âATION DE PAGES (App Router)

- Cr√©er un dossier dans `app/` avec le nom de la route
- Toujours nommer le fichier principal `page.tsx`
- Utiliser `"use client"` uniquement si n√©cessaire (interactivit√©)
- Suivre le pattern d'authentification avec les contextes

```typescript
// app/ma-page/page.tsx
"use client"; // Si n√©cessaire

export default function MaPagePage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold">Ma Page</h1>
    </div>
  );
}
```

### 3. ROUTES API

- Cr√©er un dossier dans `app/api/` avec le nom de l'endpoint
- Nommer le fichier `route.ts`
- Utiliser les m√©thodes HTTP appropri√©es (GET, POST, PUT, DELETE)
- Toujours g√©rer les erreurs avec try/catch
- Retourner des r√©ponses JSON structur√©es

```typescript
// app/api/mon-endpoint/route.ts
import { NextRequest, NextResponse } from "next/server";

export async function GET(request: NextRequest) {
  try {
    // Logique m√©tier
    return NextResponse.json({
      success: true,
      data: {},
    });
  } catch (error) {
    console.error("Erreur:", error);
    return NextResponse.json(
      { success: false, error: "Erreur serveur" },
      { status: 500 }
    );
  }
}
```

### 4. COMPOSANTS UI (shadcn/ui)

- Installer avec `pnpm dlx shadcn@latest add [component-name]`
- Tous les composants UI sont dans `components/ui/`
- Utiliser la fonction `cn()` de `lib/utils.ts` pour les classes conditionnelles
- Suivre les patterns existants pour les formulaires avec react-hook-form + zod

```typescript
// Installation d'un nouveau composant
// pnpm dlx shadcn@latest add button

// Utilisation
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

const MyButton = ({ className, ...props }: ButtonProps) => {
  return (
    <Button className={cn("bg-primary text-white", className)} {...props} />
  );
};
```

### 5. FORMULAIRES & VALIDATION

- Utiliser react-hook-form avec zodResolver
- D√©finir les sch√©mas Zod avant le composant
- Utiliser les composants Form de shadcn/ui
- G√©rer les erreurs avec useState pour les messages globaux

```typescript
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod";

const schema = z.object({
  email: z.string().email("Email invalide"),
  password: z.string().min(6, "6 caract√®res minimum"),
});

type FormData = z.infer<typeof schema>;

const MyForm = () => {
  const form = useForm<FormData>({
    resolver: zodResolver(schema),
    defaultValues: { email: "", password: "" },
  });

  const onSubmit = (data: FormData) => {
    // Logique de soumission
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* FormField components */}
      </form>
    </Form>
  );
};
```

### 6. BASE DE DONN√âES (Prisma)

- Le sch√©ma est dans `prisma/schema.prisma`
- Utiliser des relations explicites entre les mod√®les
- Enum pour les types fixes (UserRole, ServiceType, QuoteStatus)
- Toujours utiliser `@default(cuid())` pour les IDs
- Utiliser des champs optionnels avec `?` quand appropri√©

```prisma
model MonModel {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // Autres champs...
}
```

### 7. CONTEXTES REACT

- Cr√©er les contextes dans `lib/`
- Suffixer avec `-context.tsx`
- Exporter un hook personnalis√© (ex: `useAuth`, `useQuote`)
- G√©rer le localStorage quand n√©cessaire
- Suivre le pattern existant des contextes

```typescript
// lib/mon-context.tsx
"use client";

import { createContext, useContext } from "react";

type MonContextType = {
  // Types...
};

const MonContext = createContext<MonContextType | undefined>(undefined);

export const MonProvider = ({ children }: { children: React.ReactNode }) => {
  // Logique du provider
  return <MonContext.Provider value={value}>{children}</MonContext.Provider>;
};

export const useMon = () => {
  const context = useContext(MonContext);
  if (!context) {
    throw new Error("useMon doit √™tre utilis√© dans MonProvider");
  }
  return context;
};
```

### 8. UTILITAIRES (lib/utils.ts)

- Ajouter les nouvelles fonctions utilitaires dans `lib/utils.ts`
- Pr√©fixer les fonctions m√©tier avec le domaine (ex: `calculateEstimatedPrice`)
- Utiliser des noms en fran√ßais pour les fonctions de traduction
- Toujours typer les param√®tres et retours

```typescript
// Exemple de fonction utilitaire
export function formatCustomDate(date: Date): string {
  return date.toLocaleDateString("fr-FR", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
}
```

### 9. GESTION DES PACKAGES

- Utiliser `pnpm` pour installer les packages
- Pour shadcn/ui: `pnpm dlx shadcn@latest add [component]`
- Maintenir les versions dans package.json
- Utiliser `--save-dev` pour les d√©pendances de d√©veloppement

### 10. STYLES & CLASSES

- Utiliser Tailwind CSS exclusivement
- Classes responsive: mobile-first (sm:, md:, lg:, xl:)
- Utiliser les tokens de couleur du th√®me (primary, secondary, muted, etc.)
- Pr√©f√©rer les classes utilitaires aux styles custom

```typescript
// ‚úÖ BON
<div className="container mx-auto px-4 py-8 sm:px-6 lg:px-8">
  <h1 className="text-2xl font-bold text-foreground">Titre</h1>
</div>

// ‚ùå √âVITER les styles inline
<div style={{ padding: "2rem" }}>
```

### 11. NAVIGATION & ROUTING

- Utiliser `next/link` pour la navigation interne
- Utiliser `useRouter` de `next/navigation` pour la navigation programmatique
- Respect de la hi√©rarchie des routes pour l'admin (`/admin/*`)
- Prot√©ger les routes avec les contextes d'authentification

### 12. GESTION DES ERREURS

- Toujours wrapper les appels API dans try/catch
- Utiliser des messages d'erreur en fran√ßais
- Logger les erreurs avec `console.error`
- Afficher des messages utilisateur friendly

### 13. PERFORMANCE & OPTIMISATION

- Utiliser `"use client"` seulement quand n√©cessaire
- Pr√©f√©rer les Server Components par d√©faut
- Lazy loading pour les composants lourds
- Optimiser les images avec next/image

## üöÄ WORKFLOWS COMMUNS

### Ajouter une nouvelle page

1. Cr√©er le dossier dans `app/`
2. Cr√©er `page.tsx` avec le composant
3. Ajouter la navigation si n√©cessaire
4. Tester la route

### Ajouter un composant UI

1. `pnpm dlx shadcn@latest add [component-name]`
2. Importer depuis `@/components/ui/[component-name]`
3. Personnaliser si n√©cessaire

### Ajouter une route API

1. Cr√©er le dossier dans `app/api/`
2. Cr√©er `route.ts`
3. Impl√©menter les m√©thodes HTTP
4. Tester avec un client

### Modifier le sch√©ma DB

1. Modifier `prisma/schema.prisma`
2. G√©n√©rer la migration
3. Appliquer les changements
4. Mettre √† jour les types si n√©cessaire

## üé® CONVENTIONS DE NOMMAGE

- Fichiers: kebab-case (`quote-form.tsx`)
- Composants: PascalCase (`QuoteForm`)
- Variables/fonctions: camelCase (`calculatePrice`)
- Types: PascalCase (`QuoteFormData`)
- Constantes: SCREAMING_SNAKE_CASE (`API_BASE_URL`)

## üìã CHECKLIST AVANT COMMIT

- [ ] Code TypeScript sans erreurs
- [ ] Tests passent (si applicable)
- [ ] Responsive design v√©rifi√©
- [ ] Accessibilit√© respect√©e
- [ ] Messages en fran√ßais
- [ ] Gestion d'erreur impl√©ment√©e
- [ ] Performance optimis√©e
